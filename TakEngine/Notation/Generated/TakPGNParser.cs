//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.5.1
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from TakPGN.g4 by ANTLR 4.5.1

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591

using System;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;
namespace TakEngine.Notation.Generated
{
    [System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.5.1")]
    public partial class TakPGNParser : Parser
    {
        public const int
            P1_WINS_ROAD = 1, P1_WINS_FLATS = 2, P2_WINS_ROAD = 3, P2_WINS_FLATS = 4, DRAWN_GAME = 5,
            REST_OF_LINE_COMMENT = 6, BRACE_COMMENT = 7, ESCAPE = 8, SPACES = 9, STRING = 10,
            INTEGER = 11, PERIOD = 12, ASTERISK = 13, LEFT_BRACKET = 14, RIGHT_BRACKET = 15,
            LEFT_PARENTHESIS = 16, RIGHT_PARENTHESIS = 17, NUMERIC_ANNOTATION_GLYPH = 18,
            SYMBOL = 19, UNEXPECTED_CHAR = 20;
        public const int
            RULE_parse = 0, RULE_pgn_database = 1, RULE_pgn_game = 2, RULE_tag_section = 3,
            RULE_tag_pair = 4, RULE_tag_name = 5, RULE_tag_value = 6, RULE_movetext_section = 7,
            RULE_element_sequence = 8, RULE_element = 9, RULE_move_number_indication = 10,
            RULE_san_move = 11, RULE_recursive_variation = 12, RULE_game_termination = 13;
        public static readonly string[] ruleNames = {
		"parse", "pgn_database", "pgn_game", "tag_section", "tag_pair", "tag_name", 
		"tag_value", "movetext_section", "element_sequence", "element", "move_number_indication", 
		"san_move", "recursive_variation", "game_termination"
	};

        private static readonly string[] _LiteralNames = {
		null, "'R-0'", "'F-0'", "'0-R'", "'0-F'", "'1/2-1/2'", null, null, null, 
		null, null, null, "'.'", "'*'", "'['", "']'", "'('", "')'"
	};
        private static readonly string[] _SymbolicNames = {
		null, "P1_WINS_ROAD", "P1_WINS_FLATS", "P2_WINS_ROAD", "P2_WINS_FLATS", 
		"DRAWN_GAME", "REST_OF_LINE_COMMENT", "BRACE_COMMENT", "ESCAPE", "SPACES", 
		"STRING", "INTEGER", "PERIOD", "ASTERISK", "LEFT_BRACKET", "RIGHT_BRACKET", 
		"LEFT_PARENTHESIS", "RIGHT_PARENTHESIS", "NUMERIC_ANNOTATION_GLYPH", "SYMBOL", 
		"UNEXPECTED_CHAR"
	};
        public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

        [NotNull]
        public override IVocabulary Vocabulary
        {
            get
            {
                return DefaultVocabulary;
            }
        }

        public override string GrammarFileName { get { return "TakPGN.g4"; } }

        public override string[] RuleNames { get { return ruleNames; } }

        public override string SerializedAtn { get { return _serializedATN; } }

        public TakPGNParser(ITokenStream input)
            : base(input)
        {
            Interpreter = new ParserATNSimulator(this, _ATN);
        }
        public partial class ParseContext : ParserRuleContext
        {
            public Pgn_databaseContext pgn_database()
            {
                return GetRuleContext<Pgn_databaseContext>(0);
            }
            public ITerminalNode Eof() { return GetToken(TakPGNParser.Eof, 0); }
            public ParseContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }
            public override int RuleIndex { get { return RULE_parse; } }
            public override void EnterRule(IParseTreeListener listener)
            {
                ITakPGNListener typedListener = listener as ITakPGNListener;
                if (typedListener != null) typedListener.EnterParse(this);
            }
            public override void ExitRule(IParseTreeListener listener)
            {
                ITakPGNListener typedListener = listener as ITakPGNListener;
                if (typedListener != null) typedListener.ExitParse(this);
            }
        }

        [RuleVersion(0)]
        public ParseContext parse()
        {
            ParseContext _localctx = new ParseContext(Context, State);
            EnterRule(_localctx, 0, RULE_parse);
            try
            {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 28; pgn_database();
                    State = 29; Match(Eof);
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public partial class Pgn_databaseContext : ParserRuleContext
        {
            public Pgn_gameContext[] pgn_game()
            {
                return GetRuleContexts<Pgn_gameContext>();
            }
            public Pgn_gameContext pgn_game(int i)
            {
                return GetRuleContext<Pgn_gameContext>(i);
            }
            public Pgn_databaseContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }
            public override int RuleIndex { get { return RULE_pgn_database; } }
            public override void EnterRule(IParseTreeListener listener)
            {
                ITakPGNListener typedListener = listener as ITakPGNListener;
                if (typedListener != null) typedListener.EnterPgn_database(this);
            }
            public override void ExitRule(IParseTreeListener listener)
            {
                ITakPGNListener typedListener = listener as ITakPGNListener;
                if (typedListener != null) typedListener.ExitPgn_database(this);
            }
        }

        [RuleVersion(0)]
        public Pgn_databaseContext pgn_database()
        {
            Pgn_databaseContext _localctx = new Pgn_databaseContext(Context, State);
            EnterRule(_localctx, 2, RULE_pgn_database);
            int _la;
            try
            {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 34;
                    ErrorHandler.Sync(this);
                    _la = TokenStream.La(1);
                    while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << P1_WINS_ROAD) | (1L << P1_WINS_FLATS) | (1L << P2_WINS_ROAD) | (1L << P2_WINS_FLATS) | (1L << DRAWN_GAME) | (1L << INTEGER) | (1L << ASTERISK) | (1L << LEFT_BRACKET) | (1L << LEFT_PARENTHESIS) | (1L << NUMERIC_ANNOTATION_GLYPH) | (1L << SYMBOL))) != 0))
                    {
                        {
                            {
                                State = 31; pgn_game();
                            }
                        }
                        State = 36;
                        ErrorHandler.Sync(this);
                        _la = TokenStream.La(1);
                    }
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public partial class Pgn_gameContext : ParserRuleContext
        {
            public Tag_sectionContext tag_section()
            {
                return GetRuleContext<Tag_sectionContext>(0);
            }
            public Movetext_sectionContext movetext_section()
            {
                return GetRuleContext<Movetext_sectionContext>(0);
            }
            public Pgn_gameContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }
            public override int RuleIndex { get { return RULE_pgn_game; } }
            public override void EnterRule(IParseTreeListener listener)
            {
                ITakPGNListener typedListener = listener as ITakPGNListener;
                if (typedListener != null) typedListener.EnterPgn_game(this);
            }
            public override void ExitRule(IParseTreeListener listener)
            {
                ITakPGNListener typedListener = listener as ITakPGNListener;
                if (typedListener != null) typedListener.ExitPgn_game(this);
            }
        }

        [RuleVersion(0)]
        public Pgn_gameContext pgn_game()
        {
            Pgn_gameContext _localctx = new Pgn_gameContext(Context, State);
            EnterRule(_localctx, 4, RULE_pgn_game);
            try
            {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 37; tag_section();
                    State = 38; movetext_section();
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public partial class Tag_sectionContext : ParserRuleContext
        {
            public Tag_pairContext[] tag_pair()
            {
                return GetRuleContexts<Tag_pairContext>();
            }
            public Tag_pairContext tag_pair(int i)
            {
                return GetRuleContext<Tag_pairContext>(i);
            }
            public Tag_sectionContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }
            public override int RuleIndex { get { return RULE_tag_section; } }
            public override void EnterRule(IParseTreeListener listener)
            {
                ITakPGNListener typedListener = listener as ITakPGNListener;
                if (typedListener != null) typedListener.EnterTag_section(this);
            }
            public override void ExitRule(IParseTreeListener listener)
            {
                ITakPGNListener typedListener = listener as ITakPGNListener;
                if (typedListener != null) typedListener.ExitTag_section(this);
            }
        }

        [RuleVersion(0)]
        public Tag_sectionContext tag_section()
        {
            Tag_sectionContext _localctx = new Tag_sectionContext(Context, State);
            EnterRule(_localctx, 6, RULE_tag_section);
            int _la;
            try
            {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 43;
                    ErrorHandler.Sync(this);
                    _la = TokenStream.La(1);
                    while (_la == LEFT_BRACKET)
                    {
                        {
                            {
                                State = 40; tag_pair();
                            }
                        }
                        State = 45;
                        ErrorHandler.Sync(this);
                        _la = TokenStream.La(1);
                    }
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public partial class Tag_pairContext : ParserRuleContext
        {
            public ITerminalNode LEFT_BRACKET() { return GetToken(TakPGNParser.LEFT_BRACKET, 0); }
            public Tag_nameContext tag_name()
            {
                return GetRuleContext<Tag_nameContext>(0);
            }
            public Tag_valueContext tag_value()
            {
                return GetRuleContext<Tag_valueContext>(0);
            }
            public ITerminalNode RIGHT_BRACKET() { return GetToken(TakPGNParser.RIGHT_BRACKET, 0); }
            public Tag_pairContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }
            public override int RuleIndex { get { return RULE_tag_pair; } }
            public override void EnterRule(IParseTreeListener listener)
            {
                ITakPGNListener typedListener = listener as ITakPGNListener;
                if (typedListener != null) typedListener.EnterTag_pair(this);
            }
            public override void ExitRule(IParseTreeListener listener)
            {
                ITakPGNListener typedListener = listener as ITakPGNListener;
                if (typedListener != null) typedListener.ExitTag_pair(this);
            }
        }

        [RuleVersion(0)]
        public Tag_pairContext tag_pair()
        {
            Tag_pairContext _localctx = new Tag_pairContext(Context, State);
            EnterRule(_localctx, 8, RULE_tag_pair);
            try
            {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 46; Match(LEFT_BRACKET);
                    State = 47; tag_name();
                    State = 48; tag_value();
                    State = 49; Match(RIGHT_BRACKET);
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public partial class Tag_nameContext : ParserRuleContext
        {
            public ITerminalNode SYMBOL() { return GetToken(TakPGNParser.SYMBOL, 0); }
            public Tag_nameContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }
            public override int RuleIndex { get { return RULE_tag_name; } }
            public override void EnterRule(IParseTreeListener listener)
            {
                ITakPGNListener typedListener = listener as ITakPGNListener;
                if (typedListener != null) typedListener.EnterTag_name(this);
            }
            public override void ExitRule(IParseTreeListener listener)
            {
                ITakPGNListener typedListener = listener as ITakPGNListener;
                if (typedListener != null) typedListener.ExitTag_name(this);
            }
        }

        [RuleVersion(0)]
        public Tag_nameContext tag_name()
        {
            Tag_nameContext _localctx = new Tag_nameContext(Context, State);
            EnterRule(_localctx, 10, RULE_tag_name);
            try
            {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 51; Match(SYMBOL);
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public partial class Tag_valueContext : ParserRuleContext
        {
            public ITerminalNode STRING() { return GetToken(TakPGNParser.STRING, 0); }
            public Tag_valueContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }
            public override int RuleIndex { get { return RULE_tag_value; } }
            public override void EnterRule(IParseTreeListener listener)
            {
                ITakPGNListener typedListener = listener as ITakPGNListener;
                if (typedListener != null) typedListener.EnterTag_value(this);
            }
            public override void ExitRule(IParseTreeListener listener)
            {
                ITakPGNListener typedListener = listener as ITakPGNListener;
                if (typedListener != null) typedListener.ExitTag_value(this);
            }
        }

        [RuleVersion(0)]
        public Tag_valueContext tag_value()
        {
            Tag_valueContext _localctx = new Tag_valueContext(Context, State);
            EnterRule(_localctx, 12, RULE_tag_value);
            try
            {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 53; Match(STRING);
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public partial class Movetext_sectionContext : ParserRuleContext
        {
            public Element_sequenceContext element_sequence()
            {
                return GetRuleContext<Element_sequenceContext>(0);
            }
            public Game_terminationContext game_termination()
            {
                return GetRuleContext<Game_terminationContext>(0);
            }
            public Movetext_sectionContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }
            public override int RuleIndex { get { return RULE_movetext_section; } }
            public override void EnterRule(IParseTreeListener listener)
            {
                ITakPGNListener typedListener = listener as ITakPGNListener;
                if (typedListener != null) typedListener.EnterMovetext_section(this);
            }
            public override void ExitRule(IParseTreeListener listener)
            {
                ITakPGNListener typedListener = listener as ITakPGNListener;
                if (typedListener != null) typedListener.ExitMovetext_section(this);
            }
        }

        [RuleVersion(0)]
        public Movetext_sectionContext movetext_section()
        {
            Movetext_sectionContext _localctx = new Movetext_sectionContext(Context, State);
            EnterRule(_localctx, 14, RULE_movetext_section);
            try
            {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 55; element_sequence();
                    State = 56; game_termination();
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public partial class Element_sequenceContext : ParserRuleContext
        {
            public ElementContext[] element()
            {
                return GetRuleContexts<ElementContext>();
            }
            public ElementContext element(int i)
            {
                return GetRuleContext<ElementContext>(i);
            }
            public Recursive_variationContext[] recursive_variation()
            {
                return GetRuleContexts<Recursive_variationContext>();
            }
            public Recursive_variationContext recursive_variation(int i)
            {
                return GetRuleContext<Recursive_variationContext>(i);
            }
            public Element_sequenceContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }
            public override int RuleIndex { get { return RULE_element_sequence; } }
            public override void EnterRule(IParseTreeListener listener)
            {
                ITakPGNListener typedListener = listener as ITakPGNListener;
                if (typedListener != null) typedListener.EnterElement_sequence(this);
            }
            public override void ExitRule(IParseTreeListener listener)
            {
                ITakPGNListener typedListener = listener as ITakPGNListener;
                if (typedListener != null) typedListener.ExitElement_sequence(this);
            }
        }

        [RuleVersion(0)]
        public Element_sequenceContext element_sequence()
        {
            Element_sequenceContext _localctx = new Element_sequenceContext(Context, State);
            EnterRule(_localctx, 16, RULE_element_sequence);
            int _la;
            try
            {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 62;
                    ErrorHandler.Sync(this);
                    _la = TokenStream.La(1);
                    while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << INTEGER) | (1L << LEFT_PARENTHESIS) | (1L << NUMERIC_ANNOTATION_GLYPH) | (1L << SYMBOL))) != 0))
                    {
                        {
                            State = 60;
                            switch (TokenStream.La(1))
                            {
                                case INTEGER:
                                case NUMERIC_ANNOTATION_GLYPH:
                                case SYMBOL:
                                    {
                                        State = 58; element();
                                    }
                                    break;
                                case LEFT_PARENTHESIS:
                                    {
                                        State = 59; recursive_variation();
                                    }
                                    break;
                                default:
                                    throw new NoViableAltException(this);
                            }
                        }
                        State = 64;
                        ErrorHandler.Sync(this);
                        _la = TokenStream.La(1);
                    }
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public partial class ElementContext : ParserRuleContext
        {
            public Move_number_indicationContext move_number_indication()
            {
                return GetRuleContext<Move_number_indicationContext>(0);
            }
            public San_moveContext san_move()
            {
                return GetRuleContext<San_moveContext>(0);
            }
            public ITerminalNode NUMERIC_ANNOTATION_GLYPH() { return GetToken(TakPGNParser.NUMERIC_ANNOTATION_GLYPH, 0); }
            public ElementContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }
            public override int RuleIndex { get { return RULE_element; } }
            public override void EnterRule(IParseTreeListener listener)
            {
                ITakPGNListener typedListener = listener as ITakPGNListener;
                if (typedListener != null) typedListener.EnterElement(this);
            }
            public override void ExitRule(IParseTreeListener listener)
            {
                ITakPGNListener typedListener = listener as ITakPGNListener;
                if (typedListener != null) typedListener.ExitElement(this);
            }
        }

        [RuleVersion(0)]
        public ElementContext element()
        {
            ElementContext _localctx = new ElementContext(Context, State);
            EnterRule(_localctx, 18, RULE_element);
            try
            {
                State = 68;
                switch (TokenStream.La(1))
                {
                    case INTEGER:
                        EnterOuterAlt(_localctx, 1);
                        {
                            State = 65; move_number_indication();
                        }
                        break;
                    case SYMBOL:
                        EnterOuterAlt(_localctx, 2);
                        {
                            State = 66; san_move();
                        }
                        break;
                    case NUMERIC_ANNOTATION_GLYPH:
                        EnterOuterAlt(_localctx, 3);
                        {
                            State = 67; Match(NUMERIC_ANNOTATION_GLYPH);
                        }
                        break;
                    default:
                        throw new NoViableAltException(this);
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public partial class Move_number_indicationContext : ParserRuleContext
        {
            public ITerminalNode INTEGER() { return GetToken(TakPGNParser.INTEGER, 0); }
            public ITerminalNode PERIOD() { return GetToken(TakPGNParser.PERIOD, 0); }
            public Move_number_indicationContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }
            public override int RuleIndex { get { return RULE_move_number_indication; } }
            public override void EnterRule(IParseTreeListener listener)
            {
                ITakPGNListener typedListener = listener as ITakPGNListener;
                if (typedListener != null) typedListener.EnterMove_number_indication(this);
            }
            public override void ExitRule(IParseTreeListener listener)
            {
                ITakPGNListener typedListener = listener as ITakPGNListener;
                if (typedListener != null) typedListener.ExitMove_number_indication(this);
            }
        }

        [RuleVersion(0)]
        public Move_number_indicationContext move_number_indication()
        {
            Move_number_indicationContext _localctx = new Move_number_indicationContext(Context, State);
            EnterRule(_localctx, 20, RULE_move_number_indication);
            try
            {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 70; Match(INTEGER);
                    State = 71; Match(PERIOD);
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public partial class San_moveContext : ParserRuleContext
        {
            public ITerminalNode SYMBOL() { return GetToken(TakPGNParser.SYMBOL, 0); }
            public San_moveContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }
            public override int RuleIndex { get { return RULE_san_move; } }
            public override void EnterRule(IParseTreeListener listener)
            {
                ITakPGNListener typedListener = listener as ITakPGNListener;
                if (typedListener != null) typedListener.EnterSan_move(this);
            }
            public override void ExitRule(IParseTreeListener listener)
            {
                ITakPGNListener typedListener = listener as ITakPGNListener;
                if (typedListener != null) typedListener.ExitSan_move(this);
            }
        }

        [RuleVersion(0)]
        public San_moveContext san_move()
        {
            San_moveContext _localctx = new San_moveContext(Context, State);
            EnterRule(_localctx, 22, RULE_san_move);
            try
            {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 73; Match(SYMBOL);
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public partial class Recursive_variationContext : ParserRuleContext
        {
            public ITerminalNode LEFT_PARENTHESIS() { return GetToken(TakPGNParser.LEFT_PARENTHESIS, 0); }
            public Element_sequenceContext element_sequence()
            {
                return GetRuleContext<Element_sequenceContext>(0);
            }
            public ITerminalNode RIGHT_PARENTHESIS() { return GetToken(TakPGNParser.RIGHT_PARENTHESIS, 0); }
            public Recursive_variationContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }
            public override int RuleIndex { get { return RULE_recursive_variation; } }
            public override void EnterRule(IParseTreeListener listener)
            {
                ITakPGNListener typedListener = listener as ITakPGNListener;
                if (typedListener != null) typedListener.EnterRecursive_variation(this);
            }
            public override void ExitRule(IParseTreeListener listener)
            {
                ITakPGNListener typedListener = listener as ITakPGNListener;
                if (typedListener != null) typedListener.ExitRecursive_variation(this);
            }
        }

        [RuleVersion(0)]
        public Recursive_variationContext recursive_variation()
        {
            Recursive_variationContext _localctx = new Recursive_variationContext(Context, State);
            EnterRule(_localctx, 24, RULE_recursive_variation);
            try
            {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 75; Match(LEFT_PARENTHESIS);
                    State = 76; element_sequence();
                    State = 77; Match(RIGHT_PARENTHESIS);
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public partial class Game_terminationContext : ParserRuleContext
        {
            public ITerminalNode P1_WINS_ROAD() { return GetToken(TakPGNParser.P1_WINS_ROAD, 0); }
            public ITerminalNode P1_WINS_FLATS() { return GetToken(TakPGNParser.P1_WINS_FLATS, 0); }
            public ITerminalNode P2_WINS_ROAD() { return GetToken(TakPGNParser.P2_WINS_ROAD, 0); }
            public ITerminalNode P2_WINS_FLATS() { return GetToken(TakPGNParser.P2_WINS_FLATS, 0); }
            public ITerminalNode DRAWN_GAME() { return GetToken(TakPGNParser.DRAWN_GAME, 0); }
            public ITerminalNode ASTERISK() { return GetToken(TakPGNParser.ASTERISK, 0); }
            public Game_terminationContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }
            public override int RuleIndex { get { return RULE_game_termination; } }
            public override void EnterRule(IParseTreeListener listener)
            {
                ITakPGNListener typedListener = listener as ITakPGNListener;
                if (typedListener != null) typedListener.EnterGame_termination(this);
            }
            public override void ExitRule(IParseTreeListener listener)
            {
                ITakPGNListener typedListener = listener as ITakPGNListener;
                if (typedListener != null) typedListener.ExitGame_termination(this);
            }
        }

        [RuleVersion(0)]
        public Game_terminationContext game_termination()
        {
            Game_terminationContext _localctx = new Game_terminationContext(Context, State);
            EnterRule(_localctx, 26, RULE_game_termination);
            int _la;
            try
            {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 79;
                    _la = TokenStream.La(1);
                    if (!((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << P1_WINS_ROAD) | (1L << P1_WINS_FLATS) | (1L << P2_WINS_ROAD) | (1L << P2_WINS_FLATS) | (1L << DRAWN_GAME) | (1L << ASTERISK))) != 0)))
                    {
                        ErrorHandler.RecoverInline(this);
                    }
                    else
                    {
                        Consume();
                    }
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public static readonly string _serializedATN =
            "\x3\x430\xD6D1\x8206\xAD2D\x4417\xAEF1\x8D80\xAADD\x3\x16T\x4\x2\t\x2" +
            "\x4\x3\t\x3\x4\x4\t\x4\x4\x5\t\x5\x4\x6\t\x6\x4\a\t\a\x4\b\t\b\x4\t\t" +
            "\t\x4\n\t\n\x4\v\t\v\x4\f\t\f\x4\r\t\r\x4\xE\t\xE\x4\xF\t\xF\x3\x2\x3" +
            "\x2\x3\x2\x3\x3\a\x3#\n\x3\f\x3\xE\x3&\v\x3\x3\x4\x3\x4\x3\x4\x3\x5\a" +
            "\x5,\n\x5\f\x5\xE\x5/\v\x5\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\a\x3\a\x3" +
            "\b\x3\b\x3\t\x3\t\x3\t\x3\n\x3\n\a\n?\n\n\f\n\xE\n\x42\v\n\x3\v\x3\v\x3" +
            "\v\x5\vG\n\v\x3\f\x3\f\x3\f\x3\r\x3\r\x3\xE\x3\xE\x3\xE\x3\xE\x3\xF\x3" +
            "\xF\x3\xF\x2\x2\x10\x2\x4\x6\b\n\f\xE\x10\x12\x14\x16\x18\x1A\x1C\x2\x3" +
            "\x4\x2\x3\a\xF\xFK\x2\x1E\x3\x2\x2\x2\x4$\x3\x2\x2\x2\x6\'\x3\x2\x2\x2" +
            "\b-\x3\x2\x2\x2\n\x30\x3\x2\x2\x2\f\x35\x3\x2\x2\x2\xE\x37\x3\x2\x2\x2" +
            "\x10\x39\x3\x2\x2\x2\x12@\x3\x2\x2\x2\x14\x46\x3\x2\x2\x2\x16H\x3\x2\x2" +
            "\x2\x18K\x3\x2\x2\x2\x1AM\x3\x2\x2\x2\x1CQ\x3\x2\x2\x2\x1E\x1F\x5\x4\x3" +
            "\x2\x1F \a\x2\x2\x3 \x3\x3\x2\x2\x2!#\x5\x6\x4\x2\"!\x3\x2\x2\x2#&\x3" +
            "\x2\x2\x2$\"\x3\x2\x2\x2$%\x3\x2\x2\x2%\x5\x3\x2\x2\x2&$\x3\x2\x2\x2\'" +
            "(\x5\b\x5\x2()\x5\x10\t\x2)\a\x3\x2\x2\x2*,\x5\n\x6\x2+*\x3\x2\x2\x2," +
            "/\x3\x2\x2\x2-+\x3\x2\x2\x2-.\x3\x2\x2\x2.\t\x3\x2\x2\x2/-\x3\x2\x2\x2" +
            "\x30\x31\a\x10\x2\x2\x31\x32\x5\f\a\x2\x32\x33\x5\xE\b\x2\x33\x34\a\x11" +
            "\x2\x2\x34\v\x3\x2\x2\x2\x35\x36\a\x15\x2\x2\x36\r\x3\x2\x2\x2\x37\x38" +
            "\a\f\x2\x2\x38\xF\x3\x2\x2\x2\x39:\x5\x12\n\x2:;\x5\x1C\xF\x2;\x11\x3" +
            "\x2\x2\x2<?\x5\x14\v\x2=?\x5\x1A\xE\x2><\x3\x2\x2\x2>=\x3\x2\x2\x2?\x42" +
            "\x3\x2\x2\x2@>\x3\x2\x2\x2@\x41\x3\x2\x2\x2\x41\x13\x3\x2\x2\x2\x42@\x3" +
            "\x2\x2\x2\x43G\x5\x16\f\x2\x44G\x5\x18\r\x2\x45G\a\x14\x2\x2\x46\x43\x3" +
            "\x2\x2\x2\x46\x44\x3\x2\x2\x2\x46\x45\x3\x2\x2\x2G\x15\x3\x2\x2\x2HI\a" +
            "\r\x2\x2IJ\a\xE\x2\x2J\x17\x3\x2\x2\x2KL\a\x15\x2\x2L\x19\x3\x2\x2\x2" +
            "MN\a\x12\x2\x2NO\x5\x12\n\x2OP\a\x13\x2\x2P\x1B\x3\x2\x2\x2QR\t\x2\x2" +
            "\x2R\x1D\x3\x2\x2\x2\a$->@\x46";
        public static readonly ATN _ATN =
            new ATNDeserializer().Deserialize(_serializedATN.ToCharArray());
    }
}